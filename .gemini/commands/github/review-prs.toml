description = "Review, test, and merge all open pull requests in a batch operation."
prompt = """
## Instructions for Gemini

**Arguments:** {{args}}

**CRITICAL: NEVER DELETE UNPUSHED WORK**

Before deleting ANY worktree or local branch, you MUST first push all local commits to origin. This is the #1 safety rule and overrides all other instructions including speed. Losing local work is catastrophic and unrecoverable. If a push fails, STOP and leave the worktree intact.

**CRITICAL: BIAS TOWARDS ACTION**

This command is **fully automated**. Your job is to merge as many PRs as possible with minimal hesitation. You are acting as both the automation engineer and the expert reviewer.

- **DO NOT** ask for confirmation before merging.
- **DO NOT** wait unnecessarily.
- **DO NOT** over-analyze mechanical fixes ‚Äî make decisions quickly.
- **DO NOT** run tests, linting, or formatting during the merge loop ‚Äî only at the very end.
- **DO** fix issues yourself instead of deferring to the user.
- **DO** continue to the next PR if one fails ‚Äî never stop the batch.
- **DO** always push local commits to origin before deleting worktrees or branches.

**Default stance:** Merge everything first, fix quality issues once at the end. The user wants PRs merged, not status updates.

---

Review and merge all open pull requests in a logical order. Quality checks run once after all merges are complete.

**This is a batch operation** that processes multiple PRs sequentially. Each PR is merged server-side via `gh pr merge` to guarantee it is marked as **"Merged"** (not "Closed") in GitHub.

### Step 0: Setup

1.  **Enable `git rerere`:** `git config rerere.enabled true && git config rerere.autoupdate true`. This makes Git remember conflict resolutions for the fallback conflict resolution path.
2.  **Environment Check:**
    *   Record current branch: `git branch --show-current`
    *   Check status: `git status --short`
    *   **If dirty:** `git stash push -u -m "review-all-prs-autostash"` and record for restoration later.
    *   **If not on main/master/develop:** Warn but continue.

### Step 1: Fetch & Plan Merge Order

1.  **Fetch Open PRs:**
    `gh pr list --state open --json number,title,headRefName,baseRefName,labels,createdAt,updatedAt,isDraft,author`
    *   If no PRs, exit.

2.  **Analyze Files:**
    For each PR: `gh pr diff {number} --name-only`.

3.  **Determine Merge Order** using these criteria (highest priority first):
    *   **Exclude Drafts.**
    *   **Topological / Dependency order:** Infrastructure and config changes first, then shared/API layers, then business logic, then UI. PRs that are depended on by others must merge first.
    *   **Priority Labels:** (P1 > P2 > P3).
    *   **Base Branch:** (hotfix > bugfix > main/master > develop).
    *   **File Conflicts:** Group conflicting PRs together, merge oldest first to establish the baseline.
    *   **Size & Age:** Smallest and oldest as tiebreakers ‚Äî clearing small PRs first reduces queue size quickly.

4.  **Display Order:** Print the proposed merge order. **Proceed immediately.**

### Step 2: Merge Loop

For each PR in the calculated order:

#### 2.1: Review
*   **Log:** `üîÑ Processing PR #{number}: {title}`
*   **Fetch Context:**
    *   `gh pr view {number} --json body,title,url,comments,reviews`
    *   **Identify Linked Issue:** Scan for "Closes #X" or "Fixes #Y".
    *   If found, `gh issue view {issue_number} --json body,title`.
*   **Code Review:**
    *   Use `gh pr diff {number}` to analyze the changes.
    *   **Reject only for MAJOR flaws** (wrong architecture, missing core logic). Comment on PR and skip.
    *   Minor issues (bugs, typos, edge cases) ‚Äî note for fixing before merge.

#### 2.2: Apply Fixes (if needed)
*   Only enter this step if the review noted minor issues that need fixing.
*   **Fetch & Checkout:** `git fetch origin` -> `git checkout {headRefName}` -> `git pull origin {headRefName}`.
*   **Apply Fixes:** Make the necessary code changes.
*   **Commit & Push:** `git commit -am "fix: address review feedback"` -> `git push origin {headRefName}`. The fixes **must** be pushed to the PR branch so `gh pr merge` includes them.
*   **Return to target:** `git checkout {baseRefName}`.

#### 2.3: Merge via GitHub API
*   **Capture HEAD SHA:** `SHA=$(gh pr view {number} --json headRefOid --jq .headRefOid)`. This is the commit you reviewed (or just pushed fixes to). Using `--match-head-commit` prevents merging unreviewed code if someone else pushes to the branch between your review and merge.
*   **Execute Merge:** `gh pr merge {number} --merge --delete-branch --match-head-commit "$SHA"`
    *   `--merge` creates a merge commit and **preserves all individual commits** from the branch (not squash). The original commit messages remain visible in `git log`.
    *   `--delete-branch` removes the remote branch after merge.
    *   `--match-head-commit` fails the merge if the PR head has changed since review.
    *   This guarantees the PR is marked as **"Merged"** in GitHub and linked issues are auto-closed.
*   **Handle Merge Failures:**
    *   If `gh pr merge` fails due to **merge conflicts:**
        1.  `git fetch origin` -> `git checkout {headRefName}` -> `git pull origin {headRefName}`.
        2.  `git merge origin/{baseRefName}` ‚Äî merge the target branch INTO the feature branch.
        3.  **Resolve conflicts:**
            *   **Lockfiles (`package-lock.json`, etc.):** `git checkout --theirs {file}` then regenerate later in Step 3.
            *   **Simple (whitespace, imports):** Resolve automatically.
            *   **Complex:** Inspect conflict markers with `read_file`. Use expert judgment. If unresolvable, `git merge --abort` and mark as FAILED. Move to next PR.
        4.  **Verify:** Grep for `<<<<<<<` or `=======`. If found, fix immediately.
        5.  `git commit` (accept the merge commit) -> `git push origin {headRefName}`.
        6.  `git checkout {baseRefName}`.
        7.  **Re-capture SHA:** `SHA=$(gh pr view {number} --json headRefOid --jq .headRefOid)`.
        8.  **Retry:** `gh pr merge {number} --merge --delete-branch --match-head-commit "$SHA"`. If this still fails, mark as FAILED and continue.
    *   If `gh pr merge` fails due to **head commit mismatch** (someone pushed new commits): Re-review the new changes with `gh pr diff {number}`. If acceptable, re-capture SHA and retry. If suspicious, mark as FAILED and continue.
    *   If `gh pr merge` fails for **other reasons** (branch protection, CI required, etc.): Log the error, mark as FAILED, continue to next PR.
*   **Sync Local:** `git pull origin {baseRefName}` to keep local branch up to date for the next PR.

#### 2.4: Cleanup

**‚ö†Ô∏è CRITICAL: PUSH BEFORE DELETE ‚Äî DATA LOSS PREVENTION ‚ö†Ô∏è**

Before removing ANY worktree, you MUST ensure all local work is pushed to origin. Worktree removal with `--force` destroys unpushed commits permanently. This is non-negotiable.

*   **Find Worktree:** Check if `git worktree list` shows a worktree for this branch. If not, skip to branch cleanup.
*   **Push Unpushed Work:** For each worktree being removed:
    1.  `cd {worktree_path}`
    2.  **Check for uncommitted changes:** `git status --short`. If dirty: `git add -A && git commit -m "chore: save uncommitted work before cleanup"`.
    3.  **Check for unpushed commits:** `git log origin/{headRefName}..HEAD --oneline 2>/dev/null`. If there are unpushed commits (any output), you MUST push: `git push origin {headRefName}`.
    4.  **Verify push succeeded:** If `git push` fails, do NOT delete the worktree. Log the failure and continue to the next PR. Never delete a worktree with unpushed commits.
    5.  `cd` back to the main repo root.
*   **Delete Worktree:** Only after confirming all commits are pushed: `git worktree remove --force {path}`.
*   **Delete Local Branch:** `git branch -D {headRefName}` (remote branch already deleted by `--delete-branch`).
*   **Close Linked Issues:** If the PR body references "Closes #X" / "Fixes #X", GitHub should auto-close them. Verify with `gh issue view {issue_number} --json state`. If still open: `gh issue close {issue_number} --comment "Fixed via merge of PR #{number}"`.

### Step 3: Post-Merge Quality Pass (ONE TIME)

After **all** PRs have been merged (or attempted):

1.  **Sync Local:** `git checkout {target_branch}` -> `git pull origin {target_branch}`.
2.  **Install Dependencies:** `npm install` (dependencies may have changed across PRs ‚Äî this also regenerates `package-lock.json` if lockfile conflicts were resolved with `--theirs`).
3.  **Rebuild Native Modules:** `npm run rebuild` (crucial for `node-pty`).
4.  **Run Quality Checks:** `npm run check` (linting, type-checking, formatting).
5.  **Run Tests:** `npm run test` (Vitest).
6.  **Fix Loop (Max 3 attempts):**
    *   If failure: Analyze output -> Fix code -> Re-run checks/tests.
    *   If still failing after 3 attempts: Stop fixing and report the failures.
7.  **Commit & Push:** If ANY changes were made (formatting, lint fixes, type fixes, lockfile regeneration): `git commit -am "chore: post-merge fixes"` -> `git push origin {target_branch}`.

### Step 4: Final Report

1.  Restore original state (pop stash if created).
2.  Display a single list of all processed PRs with status emojis:
    *   Format: `{emoji} PR #{number}: {title}`
    *   ‚úÖ = Successfully merged
    *   ‚ùå = Failed (include brief reason in parentheses)
    *   ‚è≠Ô∏è = Skipped (draft)

    **Do NOT use separate headers like "Merged:", "Failed:", "Skipped:".** Just show one unified list.
    Only show the emoji legend if there are mixed results.

**Reminder:** You are an expert engineer. Trust your judgment. Bias for action. Speed is key.
"""
