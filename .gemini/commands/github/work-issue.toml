description = "Create worktree and start working on a GitHub issue (Canopy workflow)"
prompt = '''
**FULLY AUTONOMOUS EXECUTION - Canopy Project**

**Issue Reference:** {{args}}

**Goal:** Work autonomously to completion - PR created.

**Principles (from github-orchestration):**
- **Fix, don't ask:** If `npm run check` or `npm run test` fails, fix it.
- **Commit continuously:** Use conventional commits.
- **Worktrees:** Use a separate worktree for isolation. NEVER modify the main worktree.
- **Dependencies:** Use `npm install` and `npm run rebuild` for native modules.

### Step 1: Parse and Fetch Issue

1. Extract issue number from `{{args}}`.
2. Fetch issue details: `run_shell_command("gh issue view {number} --json title,body,comments,number", description="Fetch GitHub issue details including comments")`.
3. Assign to self: `run_shell_command("gh issue edit {number} --add-assignee @me", description="Assign issue to self on GitHub")`.

### Step 2: Create Worktree

1. **Branch Name**: Determine based on issue title and type (e.g., `feature/issue-{number}-{short-desc}`, `fix/issue-{number}-{short-desc}`).
2. **Worktree Path**: `../canopy-issue-{number}`.
3. **Base Branch**: Use `main` (Canopy's default).
4. **Command**: `run_shell_command("git worktree add -b <branch-name> <worktree-path> origin/main", description="Create a new git worktree for the issue")`.

### Step 3: Setup Environment in Worktree

1. **Enter Worktree**: `run_shell_command("cd <worktree-path>", description="Change directory to the new worktree")`.
2. **Install Dependencies**: `run_shell_command("npm install", description="Install Node.js dependencies for the Canopy project")`.
3. **Rebuild Native Modules**: `run_shell_command("npm run rebuild", description="Rebuild native modules like node-pty for Electron compatibility")`.

### Step 4: Codex Plan (Implementation Guidance)

**CRITICAL:** This step runs AUTOMATICALLY.

1. **Check for Existing Guidance**: Review issue comments for detailed instructions.
2. **Consult Codex**: If no detailed instructions exist, ask Codex for implementation ideas.
   - Command: `codex(prompt="Analyze issue #{number} (including comments). If no strict guide exists, provide a list of implementation ideas, architectural considerations, and potential pitfalls to avoid.", model="gpt-5.2", cwd="<worktree-path>")`
3. **Formulate Plan**: Take Codex's ideas into account, but use your own judgment to decide on the final implementation plan. Do not pause for user approval.

### Step 5: Implement (Autonomous with Codex)

**Loop until done:**

**Principles:**
- **Heavy Codex Usage**: Treat Codex as your tireless, detail-oriented pair programmer. Do not hesitate to call `codex()` multiple times (2, 3, or more calls are encouraged).
- **Ask for Advice**: Before complex changes, ask Codex for the best approach.
- **Deep Implementation Checks**: After writing code, ask Codex to "review this specific implementation deeply" to catch bugs early.
  - Command: `codex(prompt="<request>", model="gpt-5.2", cwd="<worktree-path>")`
- **Fix, don't ask**: Fix lint/test errors immediately.

1. **Implement Changes**: Use `write_file` and `replace` to apply code changes based on the plan.
2. **Iterative Verification**:
   - **Full Quality Check**: `run_shell_command("npm run check", description="Run Canopy's linting, type-checking, and format checks")`.
   - **Run Tests**: `run_shell_command("npm run test", description="Run Canopy's unit tests using Vitest")`.
   - **Fix Failures**: Immediately identify and fix any errors. Use `codebase_investigator` or ask Codex.
3. **Commit Regularly**:
   - `run_shell_command("git add -A", description="Stage all changes for commit")`.
   - `run_shell_command("git commit -m '<conventional-commit-message>'", description="Commit changes with a conventional message")`.

### Step 6: Codex Implementation Review

**Mandatory Review:**

1. **Request Review**: Ask Codex to perform a comprehensive code review with specific focus areas.
   - Command: `codex(prompt="Perform a rigorous and detailed code review of the implementation for issue #{number}. Check specifically for: 1. **Logic & Requirements**: Does the solution fully address the issue description and comments? 2. **Architecture & Patterns**: Are IPC channels defined in 'channels.ts' and typed correctly? Are Zustand stores used effectively without unnecessary re-renders? 3. **Resource Management**: Are event listeners cleaned up? Are timers/intervals cleared? 4. **Error Handling**: Are all async operations safe? Are errors propagated to the UI? 5. **Testing**: Are there sufficient unit tests covering the new logic? 6. **Style**: Does the code match the project's formatting and naming conventions? Provide a specific, numbered list of required fixes. If no fixes are needed, explicitly state 'Approved'.", model="gpt-5.2", cwd="<worktree-path>")`
2. **Apply Fixes**: If issues are found, fix them immediately (repeat Step 5 logic) until the review is clean.

### Step 7: Create Pull Request

**Mandatory Final Step:**

1. **Push Branch**: `run_shell_command("git push -u origin HEAD", description="Push the feature branch to origin")`.
2. **Create PR**: `run_shell_command("gh pr create --title '<PR Title>' --body 'Closes #{number}'", description="Create a new GitHub pull request")`.
3. **Report**: Display the URL of the created PR.

**Worktree Persistence**: You will NOT automatically clean up the worktree after the PR is created. It will remain available at `<worktree-path>` for potential further work during the review process. The user is responsible for removing it with `git worktree remove <path>` when the work is completely done and the worktree is no longer needed.
'''