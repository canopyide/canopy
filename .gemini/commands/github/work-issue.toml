description = "Create worktree and start working on a GitHub issue (Canopy workflow)"
prompt = "**FULLY AUTONOMOUS EXECUTION - Canopy Project**

**Issue Reference:** {{args}}

**Goal:** Work autonomously to completion - PR created.

**Principles (from github-orchestration):**
- **Fix, don't ask:** If `npm run check` or `npm run test` fails, fix it.
- **Commit continuously:** Use conventional commits.
- **Worktrees:** Use a separate worktree for isolation.
- **Dependencies:** Use `npm install` and `npm run rebuild` for native modules.

### Step 1: Parse and Fetch Issue

1. Extract issue number from `{{args}}`.
2. Fetch issue details: `run_shell_command("gh issue view {number} --json title,body,number", description="Fetch GitHub issue details")`.
3. Assign to self: `run_shell_command("gh issue edit {number} --add-assignee @me", description="Assign issue to self on GitHub")`.

### Step 2: Create Worktree

1. **Branch Name**: Determine based on issue title and type (e.g., `feature/issue-{number}-{short-desc}`, `fix/issue-{number}-{short-desc}`).
2. **Worktree Path**: `../canopy-issue-{number}`.
3. **Base Branch**: Use `main` (Canopy's default).
4. **Command**: `run_shell_command("git worktree add -b <branch-name> <worktree-path> origin/main", description="Create a new git worktree for the issue")`.

### Step 3: Setup Environment in Worktree

1. **Enter Worktree**: `run_shell_command("cd <worktree-path>", description="Change directory to the new worktree")`.
2. **Install Dependencies**: `run_shell_command("npm install", description="Install Node.js dependencies for the Canopy project")`.
3. **Rebuild Native Modules**: `run_shell_command("npm run rebuild", description="Rebuild native modules like node-pty for Electron compatibility")`.

### Step 4: Plan Implementation

1. **Analyze Issue**: Read the issue body and comments.
2. **Explore Codebase**: Use `codebase_investigator` to understand relevant parts of the Canopy system (Electron structure, React components, IPC mechanisms).
3. **Formulate Plan**: Develop a step-by-step implementation plan, noting specific files for modification, new IPC channels, UI components, and testing strategy.

### Step 5: Implement (Autonomous)

**Loop until done:**
1. **Implement Changes**: Use `write_file` and `replace` to apply code changes.
2. **Iterative Verification**:
   - **Full Quality Check**: `run_shell_command("npm run check", description="Run Canopy's linting, type-checking, and format checks")`.
   - **Run Tests**: `run_shell_command("npm run test", description="Run Canopy's unit tests using Vitest")`.
   - **Fix Failures**: Immediately identify and fix any errors. Use `codebase_investigator` for complex architectural diagnostics or `google_web_search` for external API/library issues.
3. **Commit Regularly**:
   - `run_shell_command("git add -A", description="Stage all changes for commit")`.
   - `run_shell_command("git commit -m \"<conventional-commit-message>\"", description="Commit changes with a conventional message")`.

### Step 6: Create Pull Request

**Mandatory Final Step:**

1. **Push Branch**: `run_shell_command("git push -u origin HEAD", description="Push the feature branch to origin")`.
2. **Create PR**: `run_shell_command("gh pr create --title \"<PR Title>\" --body \"Closes #{number}"", description="Create a new GitHub pull request")`.
3. **Report**: Display the URL of the created PR.

**Worktree Cleanup**: Remind the user that the worktree is still available at `<worktree-path>` and should be removed with `git worktree remove <path>` when completely done.
"