/**
 * Zod schemas for IPC payload validation between main and renderer processes.
 */

import { z } from "zod";
import { TerminalTypeSchema } from "./agent.js";

// ============================================================================
// Terminal Entry Validation Schemas
// ============================================================================

/**
 * Schema for terminal location in appState - only grid or dock are persisted.
 * Note: "trash" is a runtime state not persisted at the app level.
 */
export const AppStateTerminalLocationSchema = z.enum(["grid", "dock"]);

/**
 * Schema for terminal location in project state - includes all locations.
 */
export const TerminalLocationSchema = z.enum(["grid", "dock", "trash"]);

/**
 * Schema for panel/terminal kind - distinguishes built-in panel types.
 */
export const PanelKindSchema = z.union([
  z.enum(["terminal", "agent", "browser", "notes", "dev-preview"]),
  z.string(), // Allow extension-provided kinds
]);

/**
 * Schema for terminal entries in appState.terminals (persisted globally).
 * This is the minimal schema for ordering/metadata preservation.
 * Note: Uses AppStateTerminalLocationSchema which excludes "trash" to match StoreSchema.
 * Uses passthrough() to preserve unknown fields for forward compatibility with extensions.
 */
export const AppStateTerminalEntrySchema = z
  .object({
    id: z.string().min(1),
    type: TerminalTypeSchema,
    title: z.string(),
    cwd: z.string(),
    worktreeId: z.string().optional(),
    location: AppStateTerminalLocationSchema,
    command: z.string().optional(),
    settings: z
      .object({
        autoRestart: z.boolean().optional(),
      })
      .optional(),
    isInputLocked: z.boolean().optional(),
  })
  .passthrough();

/**
 * Schema for terminal snapshots in ProjectState.terminals (per-project state).
 * Matches the TerminalSnapshot interface from shared/types/domain.ts.
 * Uses passthrough() to preserve unknown fields for forward compatibility with extensions.
 */
export const TerminalSnapshotSchema = z
  .object({
    id: z.string().min(1),
    kind: PanelKindSchema.optional(),
    type: TerminalTypeSchema.optional(),
    agentId: z.string().optional(),
    title: z.string(),
    cwd: z.string(),
    worktreeId: z.string().optional(),
    location: TerminalLocationSchema,
    command: z.string().optional(),
    browserUrl: z.string().optional(),
    notePath: z.string().optional(),
    noteId: z.string().optional(),
    scope: z.enum(["worktree", "project"]).optional(),
    createdAt: z.number().optional(),
  })
  .passthrough();

export type AppStateTerminalEntry = z.infer<typeof AppStateTerminalEntrySchema>;
export type TerminalSnapshotEntry = z.infer<typeof TerminalSnapshotSchema>;

/**
 * Validates an array of terminal entries and returns only the valid ones.
 * Logs warnings for any filtered invalid entries.
 *
 * @param entries - The raw terminal entries array to validate
 * @param schema - The Zod schema to validate against
 * @param context - Context string for logging (e.g., "appState" or "projectState")
 * @returns Array of valid terminal entries
 */
export function filterValidTerminalEntries<T>(
  entries: unknown[] | null | undefined,
  schema: z.ZodType<T>,
  context: string
): T[] {
  // Guard against null/undefined entries array
  if (!Array.isArray(entries)) {
    if (entries !== undefined && entries !== null) {
      console.warn(`[${context}] Expected array but received ${typeof entries}`);
    }
    return [];
  }

  const validEntries: T[] = [];

  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    const result = schema.safeParse(entry);

    if (result.success) {
      validEntries.push(result.data);
    } else {
      // Prefer non-empty string id, otherwise use index
      const entryId =
        entry &&
        typeof entry === "object" &&
        "id" in entry &&
        typeof entry.id === "string" &&
        entry.id.length > 0
          ? entry.id
          : `index-${i}`;

      const flattened = result.error.flatten();
      // Log both field errors and form errors for better diagnostics
      const errorDetails =
        Object.keys(flattened.fieldErrors).length > 0
          ? flattened.fieldErrors
          : flattened.formErrors.length > 0
            ? { _errors: flattened.formErrors }
            : { type: typeof entry };

      console.warn(`[${context}] Filtering invalid terminal entry ${entryId}:`, errorDetails);
    }
  }

  return validEntries;
}

export const TerminalSpawnOptionsSchema = z.object({
  id: z.string().optional(),
  kind: z.enum(["terminal", "agent"]).optional(),
  agentId: z.string().optional(),
  cwd: z.string().optional(),
  shell: z.string().optional(),
  cols: z.number().int().positive().max(500),
  rows: z.number().int().positive(),
  command: z.string().optional(),
  env: z.record(z.string(), z.string()).optional(),
  type: TerminalTypeSchema.optional(),
  title: z.string().optional(),
  worktreeId: z.string().optional(),
  restore: z.boolean().optional(),
});

export const TerminalResizePayloadSchema = z.object({
  id: z.string().min(1),
  cols: z.number().int().positive(),
  rows: z.number().int().positive(),
});

export const FileSearchPayloadSchema = z.object({
  cwd: z.string().min(1),
  query: z.string(),
  limit: z.number().int().positive().max(100).optional(),
});

export const SlashCommandListRequestSchema = z.object({
  agentId: z.enum(["claude", "gemini", "codex", "opencode"]),
  projectPath: z.string().optional(),
});

export const CopyTreeFormatSchema = z.enum(["xml", "json", "markdown", "tree", "ndjson"]);

export const CopyTreeOptionsSchema = z
  .object({
    format: CopyTreeFormatSchema.optional(),
    filter: z.union([z.string(), z.array(z.string())]).optional(),
    exclude: z.union([z.string(), z.array(z.string())]).optional(),
    always: z.array(z.string()).optional(),
    includePaths: z.array(z.string()).optional(),
    modified: z.boolean().optional(),
    changed: z.string().optional(),
    maxFileSize: z.number().int().positive().optional(),
    maxTotalSize: z.number().int().positive().optional(),
    maxFileCount: z.number().int().positive().optional(),
    withLineNumbers: z.boolean().optional(),
    charLimit: z.number().int().positive().optional(),
  })
  .optional();

export const CopyTreeGeneratePayloadSchema = z.object({
  worktreeId: z.string().min(1),
  options: CopyTreeOptionsSchema,
});

export const CopyTreeGenerateAndCopyFilePayloadSchema = z.object({
  worktreeId: z.string().min(1),
  options: CopyTreeOptionsSchema,
});

export const CopyTreeInjectPayloadSchema = z.object({
  terminalId: z.string().min(1),
  worktreeId: z.string().min(1),
  options: CopyTreeOptionsSchema,
});

export const CopyTreeProgressSchema = z.object({
  stage: z.string(),
  progress: z.number().min(0).max(1),
  message: z.string(),
  filesProcessed: z.number().int().nonnegative().optional(),
  totalFiles: z.number().int().nonnegative().optional(),
  currentFile: z.string().optional(),
  traceId: z.string().optional(),
});

export const CopyTreeGetFileTreePayloadSchema = z.object({
  worktreeId: z.string().min(1),
  dirPath: z.string().optional(),
});

export const SystemOpenExternalPayloadSchema = z.object({
  url: z.string().url(),
});

export const SystemOpenPathPayloadSchema = z.object({
  path: z.string().min(1),
});

export const WorktreeSetActivePayloadSchema = z.object({
  worktreeId: z.string().min(1),
});

export const WorktreeCreatePayloadSchema = z.object({
  rootPath: z.string().min(1),
  options: z.object({
    baseBranch: z.string().min(1),
    newBranch: z.string().min(1),
    path: z.string().min(1),
    fromRemote: z.boolean().optional(),
  }),
});

export type TerminalSpawnOptions = z.infer<typeof TerminalSpawnOptionsSchema>;
export type TerminalResizePayload = z.infer<typeof TerminalResizePayloadSchema>;
export type FileSearchPayload = z.infer<typeof FileSearchPayloadSchema>;
export type CopyTreeOptions = z.infer<typeof CopyTreeOptionsSchema>;
export type CopyTreeGeneratePayload = z.infer<typeof CopyTreeGeneratePayloadSchema>;
export type CopyTreeGenerateAndCopyFilePayload = z.infer<
  typeof CopyTreeGenerateAndCopyFilePayloadSchema
>;
export type CopyTreeInjectPayload = z.infer<typeof CopyTreeInjectPayloadSchema>;
export type CopyTreeProgress = z.infer<typeof CopyTreeProgressSchema>;
export type CopyTreeGetFileTreePayload = z.infer<typeof CopyTreeGetFileTreePayloadSchema>;
export type SystemOpenExternalPayload = z.infer<typeof SystemOpenExternalPayloadSchema>;
export type SystemOpenPathPayload = z.infer<typeof SystemOpenPathPayloadSchema>;
export type WorktreeSetActivePayload = z.infer<typeof WorktreeSetActivePayloadSchema>;
export type WorktreeCreatePayload = z.infer<typeof WorktreeCreatePayloadSchema>;
