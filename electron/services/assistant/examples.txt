## Tool Usage Examples

This section provides concrete examples of how to use tools correctly.

### Launching Agents

**Launch Claude and ask it to say hello world:**
```
User: "Open a Claude terminal and ask it to say hello world"

agent_launch({ agentId: "claude", prompt: "Say hello world" })
```
Result: Creates Claude terminal and sends "Say hello world" as the initial prompt. One tool call does both.

**Launch Claude with an initial prompt:**
```
agent_launch({ agentId: "claude", prompt: "Review the authentication module and suggest improvements" })
```
Result: Creates Claude terminal AND sends the prompt immediately.

**Launch Codex for a specific task:**
```
agent_launch({ agentId: "codex", prompt: "Write tests for src/utils/validation.ts" })
```

**Launch agent in a specific worktree:**
```
agent_launch({ agentId: "claude", worktreeId: "/path/to/worktree", prompt: "Fix the failing tests" })
```

**Launch plain terminal:**
```
agent_launch({ agentId: "terminal" })
```

**Available agentIds:** `claude`, `codex`, `gemini`, `opencode`, `terminal`

### Sending Commands to Existing Terminals

**Send command to a specific terminal:**
```
terminal_sendCommand({ terminalId: "abc-123", command: "npm test" })
```

**Send multi-line input:**
```
terminal_sendCommand({ terminalId: "abc-123", command: "git commit -m 'Fix bug'\ngit push" })
```

### Querying State

**List all terminals:**
```
terminal_list()
```
Returns array with id, kind, agentState, worktreeId, location for each terminal.

**Get terminal output:**
```
terminal_getOutput({ terminalId: "abc-123", maxLines: 50 })
```

**Get current worktree:**
```
worktree_getCurrent()
```

**List all worktrees:**
```
worktree_list()
```

### Creating Worktrees

**Quick worktree with recipe (recommended):**
```
worktree_createWithRecipe({
  branchName: "feature-login",
  recipeId: "dev"
})
```

**Worktree from specific base branch:**
```
worktree_createWithRecipe({
  branchName: "hotfix-auth",
  baseBranch: "release/2.0",
  recipeId: "dev"
})
```

### Multi-Step Workflows

**Example: Create worktree, launch agent, assign task**

Step 1 - Create worktree:
```
worktree_createWithRecipe({ branchName: "feature-search", recipeId: "dev" })
```
Result: `{ worktreeId: "/path/to/feature-search", ... }`

Step 2 - Launch agent in new worktree with task:
```
agent_launch({
  agentId: "claude",
  worktreeId: "/path/to/feature-search",
  prompt: "Implement full-text search for the notes feature"
})
```

**Example: Monitor agent completion with autoResume (RECOMMENDED)**

User: "Run the tests and let me know when they finish"

Step 1 - Launch agent:
```
agent_launch({ agentId: "claude", prompt: "Run the test suite and fix any failures" })
```
Result: `{ terminalId: "xyz-789" }`

Step 2 - Register ONE listener with autoResume:
```
register_listener({
  eventType: "agent:completed",
  filter: { terminalId: "xyz-789" },
  once: true,
  autoResume: {
    prompt: "The test agent has completed. Get the output and summarize the results.",
    context: { metadata: { terminalId: "xyz-789", task: "test-run" } }
  }
})
```
Result: `{ listenerId: "listener-abc" }`

Note: autoResume triggers once when the listener fires, then the continuation is removed.

Step 3 - Respond immediately to user:
"Launched test runner. I'll summarize the results when complete."

**[Conversation ends - user is not blocked]**

**[Later, when agent completes, system auto-resumes with the prompt]**

Step 4 - Check results (in resumed conversation):
```
terminal_getOutput({ terminalId: "xyz-789", maxLines: 100 })
```

Step 5 - Report to user:
"Tests completed. All 47 tests passed."

**Why autoResume is better:**
- User gets immediate response, not a frozen conversation
- No multi-minute blocking waits
- System handles continuation automatically
- One listener instead of multiple

### Event Listener Patterns

**IMPORTANT: Use autoResume for agent tasks**

For any agent task that may take more than 30 seconds, use `autoResume` instead of blocking waits:

```
// RECOMMENDED: autoResume for agent tasks
register_listener({
  eventType: "agent:completed",
  filter: { terminalId: "xyz-789" },
  once: true,
  autoResume: {
    prompt: "Agent finished. Summarize the results.",
    context: { task: "my-task" }
  }
})
```

**DO NOT launch multiple agents in a loop with blocking waits.** Launch ONE agent, register ONE listener with autoResume, respond immediately.

**Monitor all terminals for waiting state:**
When any agent enters waiting state (may need user input), you'll be notified.

IMPORTANT: Only `terminal:state-changed` events are currently bridged to the assistant.
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { toState: "waiting" },
  autoResume: {
    prompt: "An agent is waiting for input. Check what it needs."
  }
})
```
Result: `{ success: true, listenerId: "abc-123", ... }`
Use the listenerId to remove the listener later.

**Monitor specific terminal for completion (with autoResume):**
```
register_listener({
  eventType: "agent:completed",
  filter: { terminalId: "xyz-789" },
  once: true,
  autoResume: {
    prompt: "The agent completed. Get output and report results.",
    context: { metadata: { terminalId: "xyz-789" } }
  }
})
```

**Handle waiting state (with autoResume):**
Register with autoResume so you're automatically invoked when the agent needs input:
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "xyz-789", toState: "waiting" },
  autoResume: {
    prompt: "The agent is waiting for input. Check what it needs and respond appropriately."
  }
})
```

When auto-resumed:
1. Query the terminal output to see what the agent is asking:
```
terminal_getOutput({ terminalId: "xyz-789", maxLines: 20 })
```
2. Check output to determine if agent truly needs input (waiting can be silence-based)
3. Either respond programmatically:
```
terminal_sendCommand({ terminalId: "xyz-789", command: "y" })
```
4. Or describe the situation to the user and wait for their decision.

**Cleanup listeners after workflow completes:**
Always remove listeners when no longer needed.
```
// After handling the notification:
remove_listener({ listenerId: "abc-123" })
```
Or list active listeners first if you didn't save the ID:
```
list_listeners()
// Returns: { success: true, count: 1, listeners: [{ listenerId: "abc-123", eventType: "terminal:state-changed", filter: {...}, createdAt: 1234567890 }] }
remove_listener({ listenerId: "abc-123" })
```

**Launch, listen, and react workflow (using autoResume):**
Complete example: launch ONE agent, register with autoResume, respond immediately.

Step 1 - Launch agent with task that may need input:
```
agent_launch({ agentId: "claude", prompt: "Update dependencies and resolve any conflicts" })
```
Result: `{ terminalId: "dep-update-001" }`

Step 2 - Register ONE listener with autoResume for completion:
```
register_listener({
  eventType: "agent:completed",
  filter: { terminalId: "dep-update-001" },
  once: true,
  autoResume: {
    prompt: "Dependency update completed. Check the output and summarize what was updated.",
    context: { metadata: { terminalId: "dep-update-001" } }
  }
})
```

Step 3 - Respond immediately to user:
"Started dependency update. I'll summarize when complete."

**[User is not blocked - they can continue other work]**

Step 4 - When auto-resumed after completion:
```
terminal_getOutput({ terminalId: "dep-update-001", maxLines: 50 })
```

Step 5 - Summarize results to user:
"Dependencies updated: react 18.2→18.3, typescript 5.0→5.4. No breaking changes."

**Alternative: Handle waiting state with separate listener**
If you need to respond to prompts during execution, add a waiting listener:
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "dep-update-001", toState: "waiting" },
  autoResume: {
    prompt: "Agent needs input. Check what it's asking and respond."
  }
})
```

**Monitor multiple terminals for completion:**
Track several parallel agents.
```
// After launching multiple agents:
// agent1 = { terminalId: "t1" }
// agent2 = { terminalId: "t2" }
// agent3 = { terminalId: "t3" }

const listeners = [
  register_listener({ eventType: "terminal:state-changed", filter: { terminalId: "t1", toState: "completed" } }),
  register_listener({ eventType: "terminal:state-changed", filter: { terminalId: "t2", toState: "completed" } }),
  register_listener({ eventType: "terminal:state-changed", filter: { terminalId: "t3", toState: "completed" } })
]
```
Notifications arrive as each agent completes - process them individually. Store listener IDs and remove as each terminal completes.

**Filter by worktree:**
Monitor agents in a specific worktree.
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { worktreeId: "/path/to/feature-branch", toState: "waiting" }
})
```

**Filter by agent type:**
Monitor only Claude agents for completion.
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { agentId: "claude", toState: "completed" }
})
```

**Single listener for multiple states:**
Use one listener and branch on the state in the handler.
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "xyz-789" }
})
```
When notification arrives, check `listenerData.data.toState`:
- If "waiting": check output and respond
- If "completed": verify success and clean up listener
- If "failed": log error and clean up listener

This pattern is more efficient than registering multiple listeners.

IMPORTANT: Filters use exact string matching. The filter `{ toState: "waiting" }` only matches the exact string "waiting", not "waiting for input" or similar.

### Common Patterns

**Send command to multiple terminals (multi-turn required):**
User says "Send /github:work-issue to all Claude terminals in worktrees"

Turn 1 - List terminals:
```
terminal_list()
```
Result:
```json
{
  "terminals": [
    { "id": "4838dfad", "agentId": "claude", "worktreeId": "/path/to/feature-issue-2071" },
    { "id": "ded50303", "agentId": "claude", "worktreeId": "/path/to/feature-issue-2070" },
    { "id": "abc12345", "agentId": "gemini", "worktreeId": null }
  ]
}
```

Turn 2 - Send commands to matching terminals (parallel):
```
terminal_sendCommand({ terminalId: "4838dfad", command: "/github:work-issue" })
terminal_sendCommand({ terminalId: "ded50303", command: "/github:work-issue" })
```

IMPORTANT: Do NOT claim you sent commands after only calling `terminal_list()`. You must actually call `terminal_sendCommand` for each terminal. The list call gives you the IDs; a second turn with send calls performs the action.

CRITICAL: After `terminal_sendCommand` returns `success: true`, that command is DONE. Do NOT call it again for the same terminal. Each terminal gets exactly ONE send call per command. Sending the same command multiple times to the same terminal is a bug.

**Find terminal by description:**
User says "kill the claude terminal working on auth"
1. Query: `terminal_list()`
2. Match by agentId="claude" and title/context containing "auth"
3. Confirm with user if multiple matches
4. Execute: `terminal_kill({ terminalId: "<matched-id>" })`

**Restart failed agent:**
1. Query: `terminal_list()` - find terminals with agentState="failed"
2. Execute: `terminal_restart({ terminalId: "<failed-id>" })`

**Open GitHub issue in sidecar:**
```
github_openIssue({ issueNumber: 123 })
```
Or in sidecar browser:
```
sidecar_openUrl({ url: "https://github.com/owner/repo/issues/123" })
```
