## Tool Usage Examples

This section provides concrete examples of how to use tools correctly.

### Launching Agents

**Launch Claude and ask it to say hello world:**
```
User: "Open a Claude terminal and ask it to say hello world"

agent_launch({ agentId: "claude", prompt: "Say hello world" })
```
Result: Creates Claude terminal and sends "Say hello world" as the initial prompt. One tool call does both.

**Launch Claude with an initial prompt:**
```
agent_launch({ agentId: "claude", prompt: "Review the authentication module and suggest improvements" })
```
Result: Creates Claude terminal AND sends the prompt immediately.

**Launch Codex for a specific task:**
```
agent_launch({ agentId: "codex", prompt: "Write tests for src/utils/validation.ts" })
```

**Launch agent in a specific worktree:**
```
agent_launch({ agentId: "claude", worktreeId: "/path/to/worktree", prompt: "Fix the failing tests" })
```

**Launch plain terminal:**
```
agent_launch({ agentId: "terminal" })
```

**Available agentIds:** `claude`, `codex`, `gemini`, `opencode`, `terminal`

### Sending Commands to Existing Terminals

**Send command to a specific terminal:**
```
terminal_sendCommand({ terminalId: "abc-123", command: "npm test" })
```

**Send multi-line input:**
```
terminal_sendCommand({ terminalId: "abc-123", command: "git commit -m 'Fix bug'\ngit push" })
```

### Querying State

**List all terminals:**
```
terminal_list()
```
Returns array with id, kind, agentState, worktreeId, location for each terminal.

**Get terminal output:**
```
terminal_getOutput({ terminalId: "abc-123", maxLines: 50 })
```

**Get current worktree:**
```
worktree_getCurrent()
```

**List all worktrees:**
```
worktree_list()
```

### Creating Worktrees

**Quick worktree with recipe (recommended):**
```
worktree_createWithRecipe({
  branchName: "feature-login",
  recipeId: "dev"
})
```

**Worktree from specific base branch:**
```
worktree_createWithRecipe({
  branchName: "hotfix-auth",
  baseBranch: "release/2.0",
  recipeId: "dev"
})
```

### Multi-Step Workflows

**Example: Create worktree, launch agent, assign task**

Step 1 - Create worktree:
```
worktree_createWithRecipe({ branchName: "feature-search", recipeId: "dev" })
```
Result: `{ worktreeId: "/path/to/feature-search", ... }`

Step 2 - Launch agent in new worktree with task:
```
agent_launch({
  agentId: "claude",
  worktreeId: "/path/to/feature-search",
  prompt: "Implement full-text search for the notes feature"
})
```

**Example: Monitor agent completion**

User: "Run the tests and let me know when they finish"

Step 1 - Launch agent:
```
agent_launch({ agentId: "claude", prompt: "Run the test suite and fix any failures" })
```
Result: `{ terminalId: "xyz-789" }`

Step 2 - Register listeners for completion and failure:
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "xyz-789", toState: "completed" }
})
register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "xyz-789", toState: "failed" }
})
```
Result: `{ listenerId: "listener-abc" }` and `{ listenerId: "listener-def" }`

Step 3 - Inform user:
"Running tests. I'll notify you when complete."

Step 4 - When listener triggers (you receive notification chunk):
Payload: `{ type: "listener_triggered", listenerData: { listenerId: "listener-abc", eventType: "terminal:state-changed", data: { terminalId: "xyz-789", toState: "completed", ... } } }`

Step 5 - Check results:
```
terminal_getOutput({ terminalId: "xyz-789", maxLines: 100 })
```

Step 6 - Report to user:
"Tests completed. All 47 tests passed."

Step 7 - Clean up listeners:
```
remove_listener({ listenerId: "listener-abc" })
remove_listener({ listenerId: "listener-def" })
```

### Event Listener Patterns

**Monitor all terminals for waiting state:**
When any agent enters waiting state (may need user input), you'll be notified.

IMPORTANT: Only `terminal:state-changed` events are currently bridged to the assistant.
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { toState: "waiting" }
})
```
Result: `{ success: true, listenerId: "abc-123", ... }`
Use the listenerId to remove the listener later.

**Monitor specific terminal for multiple outcomes:**
Register separate listeners for completion and failure.
```
// Listen for success
register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "xyz-789", toState: "completed" }
})

// Listen for failure
register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "xyz-789", toState: "failed" }
})
```

**Handle waiting state with user notification:**
When a listener triggers for waiting state:
1. The notification chunk arrives with payload: `{ type: "listener_triggered", listenerData: { listenerId, eventType: "terminal:state-changed", data: { terminalId, agentId, toState: "waiting", ... } } }`
2. Query the terminal output to see what the agent is asking:
```
terminal_getOutput({ terminalId: "xyz-789", maxLines: 20 })
```
3. Check output to determine if agent truly needs input (waiting can be silence-based)
4. Either respond programmatically:
```
terminal_sendCommand({ terminalId: "xyz-789", command: "y" })
```
5. Or describe the situation to the user and wait for their decision.

**Cleanup listeners after workflow completes:**
Always remove listeners when no longer needed.
```
// After handling the notification:
remove_listener({ listenerId: "abc-123" })
```
Or list active listeners first if you didn't save the ID:
```
list_listeners()
// Returns: { success: true, count: 1, listeners: [{ listenerId: "abc-123", eventType: "terminal:state-changed", filter: {...}, createdAt: 1234567890 }] }
remove_listener({ listenerId: "abc-123" })
```

**Launch, listen, and react workflow:**
Complete example: launch agent, monitor for waiting/completion/failure, handle prompt.

Step 1 - Launch agent with task that may need input:
```
agent_launch({ agentId: "claude", prompt: "Update dependencies and resolve any conflicts" })
```
Result: `{ terminalId: "dep-update-001" }`

Step 2 - Register listeners for waiting, completed, and failed states upfront:
```
const l1 = register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "dep-update-001", toState: "waiting" }
})
const l2 = register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "dep-update-001", toState: "completed" }
})
const l3 = register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "dep-update-001", toState: "failed" }
})
```
Store listener IDs: `l1.listenerId`, `l2.listenerId`, `l3.listenerId`

Step 3 - When waiting notification arrives:
```
terminal_getOutput({ terminalId: "dep-update-001", maxLines: 30 })
```
Output shows: "Package react has breaking changes. Proceed? (y/n)"

Step 4 - Respond to prompt:
```
terminal_sendCommand({ terminalId: "dep-update-001", command: "y" })
```

Step 5 - When completed/failed notification arrives, clean up all listeners:
```
remove_listener({ listenerId: l1.listenerId })
remove_listener({ listenerId: l2.listenerId })
remove_listener({ listenerId: l3.listenerId })
```

**Monitor multiple terminals for completion:**
Track several parallel agents.
```
// After launching multiple agents:
// agent1 = { terminalId: "t1" }
// agent2 = { terminalId: "t2" }
// agent3 = { terminalId: "t3" }

const listeners = [
  register_listener({ eventType: "terminal:state-changed", filter: { terminalId: "t1", toState: "completed" } }),
  register_listener({ eventType: "terminal:state-changed", filter: { terminalId: "t2", toState: "completed" } }),
  register_listener({ eventType: "terminal:state-changed", filter: { terminalId: "t3", toState: "completed" } })
]
```
Notifications arrive as each agent completes - process them individually. Store listener IDs and remove as each terminal completes.

**Filter by worktree:**
Monitor agents in a specific worktree.
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { worktreeId: "/path/to/feature-branch", toState: "waiting" }
})
```

**Filter by agent type:**
Monitor only Claude agents for completion.
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { agentId: "claude", toState: "completed" }
})
```

**Single listener for multiple states:**
Use one listener and branch on the state in the handler.
```
register_listener({
  eventType: "terminal:state-changed",
  filter: { terminalId: "xyz-789" }
})
```
When notification arrives, check `listenerData.data.toState`:
- If "waiting": check output and respond
- If "completed": verify success and clean up listener
- If "failed": log error and clean up listener

This pattern is more efficient than registering multiple listeners.

IMPORTANT: Filters use exact string matching. The filter `{ toState: "waiting" }` only matches the exact string "waiting", not "waiting for input" or similar.

### Common Patterns

**Send command to multiple terminals (multi-turn required):**
User says "Send /github:work-issue to all Claude terminals in worktrees"

Turn 1 - List terminals:
```
terminal_list()
```
Result:
```json
{
  "terminals": [
    { "id": "4838dfad", "agentId": "claude", "worktreeId": "/path/to/feature-issue-2071" },
    { "id": "ded50303", "agentId": "claude", "worktreeId": "/path/to/feature-issue-2070" },
    { "id": "abc12345", "agentId": "gemini", "worktreeId": null }
  ]
}
```

Turn 2 - Send commands to matching terminals (parallel):
```
terminal_sendCommand({ terminalId: "4838dfad", command: "/github:work-issue" })
terminal_sendCommand({ terminalId: "ded50303", command: "/github:work-issue" })
```

IMPORTANT: Do NOT claim you sent commands after only calling `terminal_list()`. You must actually call `terminal_sendCommand` for each terminal. The list call gives you the IDs; a second turn with send calls performs the action.

CRITICAL: After `terminal_sendCommand` returns `success: true`, that command is DONE. Do NOT call it again for the same terminal. Each terminal gets exactly ONE send call per command. Sending the same command multiple times to the same terminal is a bug.

**Find terminal by description:**
User says "kill the claude terminal working on auth"
1. Query: `terminal_list()`
2. Match by agentId="claude" and title/context containing "auth"
3. Confirm with user if multiple matches
4. Execute: `terminal_kill({ terminalId: "<matched-id>" })`

**Restart failed agent:**
1. Query: `terminal_list()` - find terminals with agentState="failed"
2. Execute: `terminal_restart({ terminalId: "<failed-id>" })`

**Open GitHub issue in sidecar:**
```
github_openIssue({ issueNumber: 123 })
```
Or in sidecar browser:
```
sidecar_openUrl({ url: "https://github.com/owner/repo/issues/123" })
```
