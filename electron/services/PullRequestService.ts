import { events } from "./events.js";
import { batchCheckLinkedPRs, type PRCheckCandidate, type LinkedPR } from "./GitHubService.js";
import { logInfo, logWarn, logDebug } from "../utils/logger.js";
import type { WorktreeState } from "./WorktreeMonitor.js";

const DEFAULT_POLL_INTERVAL_MS = 60 * 1000;

const ERROR_BACKOFF_INTERVALS = [5 * 60 * 1000, 10 * 60 * 1000, 30 * 60 * 1000];

const MAX_CONSECUTIVE_ERRORS = 3;
const UPDATE_DEBOUNCE_MS = 100;

interface WorktreeContext {
  issueNumber?: number;
  branchName?: string;
}

export interface PRDetectionResult {
  worktreeId: string;
  prNumber: number;
  prUrl: string;
  prState: "open" | "merged" | "closed";
}

class PullRequestService {
  private pollTimer: NodeJS.Timeout | null = null;
  private pollIntervalMs: number = DEFAULT_POLL_INTERVAL_MS;
  private cwd: string = "";
  private isPolling: boolean = false;
  private consecutiveErrors: number = 0;
  private isEnabled: boolean = true;

  private candidates = new Map<string, WorktreeContext>();
  private resolvedWorktrees = new Set<string>();
  private detectedPRs = new Map<string, LinkedPR>();
  private updateDebounceTimer: NodeJS.Timeout | null = null;
  private unsubscribers: (() => void)[] = [];

  constructor() {
    this.unsubscribers.push(events.on("sys:worktree:update", this.handleWorktreeUpdate.bind(this)));
    this.unsubscribers.push(events.on("sys:worktree:remove", this.handleWorktreeRemove.bind(this)));
  }

  private handleWorktreeUpdate(state: WorktreeState): void {
    if (!this.isPolling) {
      return;
    }

    const currentContext = this.candidates.get(state.worktreeId);
    const newIssueNumber = state.issueNumber;
    const newBranchName = state.branch;

    const contextChanged =
      currentContext?.issueNumber !== newIssueNumber ||
      currentContext?.branchName !== newBranchName;

    if (contextChanged && currentContext) {
      logInfo("Worktree context changed - clearing PR state", {
        worktreeId: state.worktreeId,
        oldIssue: currentContext.issueNumber,
        newIssue: newIssueNumber,
        oldBranch: currentContext.branchName,
        newBranch: newBranchName,
      });

      this.resolvedWorktrees.delete(state.worktreeId);
      this.detectedPRs.delete(state.worktreeId);

      events.emit("sys:pr:cleared", { worktreeId: state.worktreeId });
    }

    if (newIssueNumber) {
      this.candidates.set(state.worktreeId, {
        issueNumber: newIssueNumber,
        branchName: newBranchName,
      });

      if (contextChanged || !currentContext) {
        this.scheduleDebounceCheck();
      }
    } else {
      if (currentContext) {
        this.candidates.delete(state.worktreeId);
        logDebug("Worktree no longer has issue number - removed from candidates", {
          worktreeId: state.worktreeId,
        });
      }
    }
  }

  private handleWorktreeRemove({ worktreeId }: { worktreeId: string }): void {
    if (this.candidates.has(worktreeId) || this.detectedPRs.has(worktreeId)) {
      this.candidates.delete(worktreeId);
      this.resolvedWorktrees.delete(worktreeId);
      this.detectedPRs.delete(worktreeId);

      events.emit("sys:pr:cleared", { worktreeId });

      logDebug("Worktree removed - cleared PR state", { worktreeId });
    }
  }

  private scheduleDebounceCheck(): void {
    if (this.updateDebounceTimer) {
      clearTimeout(this.updateDebounceTimer);
    }

    this.updateDebounceTimer = setTimeout(() => {
      this.updateDebounceTimer = null;

      if (this.hasUnresolvedCandidates()) {
        logDebug("Running debounced PR check", { candidateCount: this.candidates.size });
        void this.checkForPRs();

        if (!this.pollTimer) {
          this.scheduleNextPoll();
        }
      }
    }, UPDATE_DEBOUNCE_MS);
  }

  public initialize(cwd: string): void {
    this.cwd = cwd;
    logInfo("PullRequestService initialized", { cwd });
  }

  public start(intervalMs?: number): void {
    if (this.isPolling) {
      logWarn("PullRequestService already polling");
      return;
    }

    if (!this.cwd) {
      logWarn("PullRequestService not initialized - call initialize() first");
      return;
    }

    if (intervalMs) {
      if (intervalMs < DEFAULT_POLL_INTERVAL_MS) {
        logWarn("PR polling interval too short - clamping to minimum 60s", {
          requested: intervalMs,
          clamped: DEFAULT_POLL_INTERVAL_MS,
        });
        this.pollIntervalMs = DEFAULT_POLL_INTERVAL_MS;
      } else {
        this.pollIntervalMs = intervalMs;
      }
    }

    this.isPolling = true;
    this.isEnabled = true;
    this.consecutiveErrors = 0;

    logInfo("PullRequestService started", { intervalMs: this.pollIntervalMs });

    this.scheduleNextPoll();
  }

  public stop(): void {
    if (this.pollTimer) {
      clearTimeout(this.pollTimer);
      this.pollTimer = null;
    }
    if (this.updateDebounceTimer) {
      clearTimeout(this.updateDebounceTimer);
      this.updateDebounceTimer = null;
    }
    this.isPolling = false;
    logInfo("PullRequestService stopped");
  }

  public async refresh(): Promise<void> {
    if (!this.cwd) {
      return;
    }
    this.isEnabled = true;
    this.consecutiveErrors = 0;
    await this.checkForPRs();

    if (this.isPolling && !this.pollTimer && this.hasUnresolvedCandidates()) {
      this.scheduleNextPoll();
    }
  }

  public reset(): void {
    this.stop();
    this.candidates.clear();
    this.resolvedWorktrees.clear();
    this.detectedPRs.clear();
    this.consecutiveErrors = 0;
    this.isEnabled = true;
  }

  public destroy(): void {
    this.reset();
    for (const unsubscribe of this.unsubscribers) {
      unsubscribe();
    }
    this.unsubscribers = [];
  }

  private scheduleNextPoll(): void {
    if (!this.isPolling || !this.isEnabled) {
      return;
    }

    if (!this.hasUnresolvedCandidates()) {
      logDebug("All candidates resolved - pausing polling");
      return;
    }

    let interval = this.pollIntervalMs;
    if (this.consecutiveErrors > 0) {
      const backoffIndex = Math.min(this.consecutiveErrors - 1, ERROR_BACKOFF_INTERVALS.length - 1);
      interval = ERROR_BACKOFF_INTERVALS[backoffIndex];
      logDebug("Using backoff interval", { errors: this.consecutiveErrors, intervalMs: interval });
    }

    this.pollTimer = setTimeout(() => {
      this.pollTimer = null;
      void this.checkForPRs().then(() => this.scheduleNextPoll());
    }, interval);
  }

  private hasUnresolvedCandidates(): boolean {
    for (const worktreeId of this.candidates.keys()) {
      if (!this.resolvedWorktrees.has(worktreeId)) {
        return true;
      }
    }
    return false;
  }

  private async checkForPRs(): Promise<void> {
    const activeCandidates: PRCheckCandidate[] = [];
    for (const [worktreeId, context] of this.candidates) {
      if (!this.resolvedWorktrees.has(worktreeId)) {
        activeCandidates.push({
          worktreeId,
          issueNumber: context.issueNumber,
          branchName: context.branchName,
        });
      }
    }

    if (activeCandidates.length === 0) {
      logDebug("No candidates to check for PRs");
      return;
    }

    logDebug("Checking PRs for candidates", { count: activeCandidates.length });

    try {
      const result = await batchCheckLinkedPRs(this.cwd, activeCandidates);

      if (result.error) {
        this.handleError(result.error);
        return;
      }

      this.consecutiveErrors = 0;

      for (const [worktreeId, checkResult] of result.results) {
        if (checkResult.pr) {
          this.resolvedWorktrees.add(worktreeId);
          this.detectedPRs.set(worktreeId, checkResult.pr);

          logInfo("PR detected for worktree", {
            worktreeId,
            prNumber: checkResult.pr.number,
            prState: checkResult.pr.state,
          });

          events.emit("sys:pr:detected", {
            worktreeId,
            prNumber: checkResult.pr.number,
            prUrl: checkResult.pr.url,
            prState: checkResult.pr.state,
            issueNumber: checkResult.issueNumber!,
          });
        }
      }
    } catch (error) {
      this.handleError(error instanceof Error ? error.message : "Unknown error");
    }
  }

  private handleError(errorMsg: string): void {
    this.consecutiveErrors++;
    logWarn("PR check failed", { error: errorMsg, consecutiveErrors: this.consecutiveErrors });

    if (this.consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
      logWarn("Too many consecutive errors - disabling PR polling");
      this.isEnabled = false;
      events.emit("ui:notify", {
        type: "warning",
        message: "PR detection paused due to errors. Refresh to retry.",
        id: "pr-service-circuit-breaker",
      });
    }
  }

  public getStatus(): {
    isPolling: boolean;
    isEnabled: boolean;
    candidateCount: number;
    resolvedCount: number;
    consecutiveErrors: number;
  } {
    return {
      isPolling: this.isPolling,
      isEnabled: this.isEnabled,
      candidateCount: this.candidates.size,
      resolvedCount: this.resolvedWorktrees.size,
      consecutiveErrors: this.consecutiveErrors,
    };
  }
}

export const pullRequestService = new PullRequestService();
